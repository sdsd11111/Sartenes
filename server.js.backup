require('dotenv').config();

const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const path = require('path');
const fs = require('fs');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const bcrypt = require('bcryptjs');
const { createClient } = require('@supabase/supabase-js');
const multer = require('multer');
const { isAuthenticated, verifyCredentials, adminAuth } = require('./middlewares/auth');

const app = express();
const PORT = process.env.PORT || 3002; // Cambiado a 3002 para desarrollo local
const isProduction = process.env.NODE_ENV === 'production';

// Configuraci√≥n de sesi√≥n
const sessionConfig = {
    secret: process.env.SESSION_SECRET || 'tu_secreto_seguro_aqui',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: isProduction,
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 horas
    }
};

if (isProduction) {
    app.set('trust proxy', 1); // Conf√≠a en el proxy de Vercel/Heroku/Nginx
    sessionConfig.cookie.secure = true;
}

app.use(cookieParser());
app.use(session(sessionConfig));

// Inicializar Supabase
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// Funci√≥n para verificar y crear el bucket si no existe
async function ensureBucketExists() {
  try {
    console.log('Verificando si el bucket "platos" existe...');
    const { data: bucketExists } = await supabase.storage.getBucket('platos');
    
    if (!bucketExists) {
      console.log('El bucket "platos" no existe, cre√°ndolo...');
      const { data: newBucket, error: createError } = await supabase.storage.createBucket('platos', {
        public: true,
        allowedMimeTypes: ['image/*'],
        fileSizeLimit: 1024 * 1024 * 5, // 5MB
      });
      
      if (createError) {
        console.error('Error al crear el bucket:', createError);
        if (createError.message.includes('already exists')) {
          console.log('El bucket ya existe, continuando...');
        } else {
          throw createError;
        }
      } else {
        console.log('Bucket "platos" creado exitosamente');
      }
    } else {
      console.log('El bucket "platos" ya existe');
    }
  } catch (error) {
    console.error('Error al verificar/crear el bucket:', error);
  }
}

// Funci√≥n para configurar las pol√≠ticas del bucket
async function configureBucketPolicies() {
  try {
    console.log('Configurando pol√≠ticas del bucket "platos"...');
    
    // Pol√≠tica de lectura p√∫blica
    const { error: readPolicyError } = await supabase.rpc('create_or_update_policy', {
      policy_name: 'Permitir lectura p√∫blica',
      table_name: 'objects',
      using: "bucket_id = 'platos'",
      with_check: "bucket_id = 'platos'"
    });
    
    if (readPolicyError) {
      if (!readPolicyError.message.includes('already exists')) {
        console.error('Error al configurar pol√≠tica de lectura:', readPolicyError);
      } else {
        console.log('Pol√≠tica de lectura ya configurada');
      }
    } else {
      console.log('Pol√≠tica de lectura configurada correctamente');
    }
    
    // Pol√≠tica de subida para autenticados
    const { error: uploadPolicyError } = await supabase.rpc('create_or_update_policy', {
      policy_name: 'Permitir subida a autenticados',
      table_name: 'objects',
      using: "bucket_id = 'platos' AND auth.role() = 'authenticated'",
      with_check: "bucket_id = 'platos' AND auth.role() = 'authenticated'"
    });
    
    if (uploadPolicyError) {
      if (!uploadPolicyError.message.includes('already exists')) {
        console.error('Error al configurar pol√≠tica de subida:', uploadPolicyError);
      } else {
        console.log('Pol√≠tica de subida ya configurada');
      }
    } else {
      console.log('Pol√≠tica de subida configurada correctamente');
    }
    
  } catch (error) {
    console.error('Error al configurar pol√≠ticas:', error);
  }
}

// Llamar a las funciones al iniciar el servidor
async function initializeApp() {
  await ensureBucketExists();
  await configureBucketPolicies();
  
  // Iniciar el servidor
  app.listen(PORT, () => {
    console.log('='.repeat(60));
    console.log(`üöÄ Servidor iniciado en http://localhost:${PORT}`);
    console.log(`üåç Entorno: ${isProduction ? 'producci√≥n' : 'desarrollo'}`);
    console.log(`üîó Supabase: ${process.env.SUPABASE_URL ? '‚úÖ Configurado' : '‚ùå No configurado'}`);
    console.log(`üìÇ Directorio p√∫blico: ${publicPath}`);
    console.log('='.repeat(60));
  });
}

// Iniciar la aplicaci√≥n
initializeApp().catch(console.error);

// Middleware para verificar autenticaci√≥n
const requireAuth = (req, res, next) => {
    if (req.cookies?.auth_token) {
        return next();
    }
    
    if (req.xhr || req.headers.accept?.includes('application/json')) {
        return res.status(401).json({ error: 'No autorizado' });
    }
    
    res.redirect('/admin/login');
};

// Middleware para redirigir usuarios autenticados lejos de la p√°gina de login
const redirectIfAuthenticated = (req, res, next) => {
    if (req.cookies?.auth_token) {
        return res.redirect('/admin');
    }
    next();
};

// Configurar Multer para manejar archivos en memoria
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024, // L√≠mite de 5MB
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten im√°genes (JPEG, PNG, etc.)'), false);
    }
  },
});

// Middleware para manejar errores de Multer
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    // Error de Multer (ej: archivo muy grande)
    return res.status(400).json({
      error: 'Error al procesar el archivo',
      details: err.message
    });
  } else if (err) {
    // Otros errores
    return res.status(500).json({
      error: 'Error interno del servidor',
      details: err.message
    });
  }
  next();
});

// Middleware de logs
app.use(morgan('dev'));

// Middleware para parsear JSON
// Parse JSON bodies
app.use(express.json());
// Parse URL-encoded bodies
app.use(express.urlencoded({ extended: true }));

// Add middleware to log incoming requests
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  if ((req.method === 'POST' || req.method === 'PUT') && req.path === '/api/platos') {
    console.log('=== INICIO DE SOLICITUD', req.method, req.path, '===');
    console.log('Headers:', req.headers);
    console.log('Body recibido:', req.body);
    console.log('Archivo recibido:', req.file ? 'S√≠' : 'No');
  }
  next();
});

// Configuraci√≥n de CORS
console.log('Configurando CORS...');
const corsOptions = {
  origin: function (origin, callback) {
    // En producci√≥n, permite cualquier origen
    if (process.env.NODE_ENV === 'production') {
      console.log('Permitiendo cualquier origen en producci√≥n');
      return callback(null, true);
    }
    
    // En desarrollo, permite localhost y la URL de Vercel
    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:9000',
      'https://sartenes.vercel.app',
      'https://sartenes-git-main-cristhopheryeah113.vercel.app',
      /^\.*\.vercel\.app$/, // Permite cualquier subdominio de vercel.app
      /^http:\/\/localhost:\d+$/ // Permite cualquier puerto localhost
    ];
    
    console.log('Origen de la solicitud:', origin || 'No especificado');
    
    // Si no hay origen (puede pasar con solicitudes no navegador, como Postman)
    if (!origin) {
      console.log('Permitiendo solicitud sin origen (probablemente no es del navegador)');
      return callback(null, true);
    }
    
    // Verificar si el origen est√° permitido
    const isAllowed = allowedOrigins.some(allowedOrigin => {
      if (typeof allowedOrigin === 'string') {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn('Origen no permitido por CORS:', origin);
      callback(new Error('No permitido por CORS'));
    }
  },
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin', 'Content-Length'],
  exposedHeaders: ['Content-Length', 'X-Foo', 'X-Bar', 'Content-Type'],
  maxAge: 86400 // 24 hours
};

// Aplicar CORS a todas las rutas
console.log('Aplicando middleware CORS...');
app.use(cors(corsOptions));

// Middleware para manejar preflight requests
app.options('*', cors(corsOptions));

// Middleware para loggear todas las solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  console.log('Headers:', req.headers);
  console.log('Body:', req.body);
  next();
});

// Middleware para manejar preflight requests
app.options('*', cors(corsOptions));

// Middleware para agregar headers CORS manualmente si es necesario
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // Responder inmediatamente a las solicitudes OPTIONS
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  next();
});

// Parsear JSON y datos de formulario
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Middleware para log de solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  console.log('Headers:', req.headers);
  console.log('Body:', req.body);
  next();
});

// Configuraci√≥n de archivos est√°ticos
const publicPath = path.join(__dirname, 'public');

// Configuraci√≥n espec√≠fica para producci√≥n
if (isProduction) {
  console.log('Ejecutando en modo producci√≥n');
  // Asegurarse de que las rutas sean correctas en producci√≥n
  app.set('trust proxy', 1);
}

// Crear directorio p√∫blico si no existe
if (!fs.existsSync(publicPath)) {
  fs.mkdirSync(publicPath, { recursive: true });
}

// Configuraci√≥n para servir archivos est√°ticos
const staticOptions = {
  setHeaders: (res, path) => {
    // Configurar cabeceras de cach√© para archivos est√°ticos
    if (path.match(/\.(js|css|json|xml)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    } else if (path.endsWith('.css')) {
      res.setHeader('Content-Type', 'text/css');
    } else if (path.endsWith('.js')) {
      res.setHeader('Content-Type', 'application/javascript');
    } else if (path.endsWith('.html')) {
      res.setHeader('Content-Type', 'text/html');
    } else if (path.match(/\.(jpg|jpeg|png|gif|svg|webp|avif|ico)$/i)) {
      // No cache for images in development
      if (!isProduction) {
        res.setHeader('Cache-Control', 'no-store');
      }
    }
  }
};

// Servir archivos est√°ticos desde la carpeta public (sin autenticaci√≥n)
app.use(express.static(publicPath, {
  ...staticOptions,
  // Permitir acceso a archivos est√°ticos sin autenticaci√≥n
  setHeaders: (res, path) => {
    if (staticOptions.setHeaders) {
      staticOptions.setHeaders(res, path);
    }
  }
}));

// Ruta espec√≠fica para los componentes (sin autenticaci√≥n)
app.use('/components', express.static(path.join(__dirname, 'public', 'components'), {
  setHeaders: (res, path) => {
    res.setHeader('Cache-Control', 'public, max-age=3600');
  }
}));

// Ruta para manejar los archivos HTML de los platos
app.get('/menu/platos/:plato', (req, res) => {
  // Asegurarse de que el nombre del archivo termine con .html
  const plato = req.params.plato.endsWith('.html') ? req.params.plato : `${req.params.plato}.html`;
  const filePath = path.join(publicPath, 'menu', 'platos', plato);
  
  console.log(`Buscando archivo de plato: ${filePath}`);
  
  // Verificar si el archivo existe
  if (fs.existsSync(filePath)) {
    console.log(`Enviando archivo: ${filePath}`);
    return res.sendFile(filePath);
  } else {
    console.log(`Archivo no encontrado: ${filePath}`);
    return res.status(404).sendFile(path.join(publicPath, '404.html'));
  }
});

// Ruta para servir archivos est√°ticos
app.get('*', (req, res, next) => {
  // Si la ruta comienza con /api, pasar al siguiente middleware
  if (req.path.startsWith('/api/')) {
    return next();
  }
  
  // Si es un archivo est√°tico (tiene extensi√≥n), intentar servirlo
  if (req.path.match(/\.[^/]+$/)) {
    const filePath = path.join(publicPath, req.path);
    if (fs.existsSync(filePath)) {
      return res.sendFile(filePath);
    }
    return res.status(404).end();
  }
  
  // Para cualquier otra ruta, servir index.html (para SPA)
  res.sendFile(path.join(publicPath, 'index.html'));
});

// Ruta para verificar que el servidor est√° funcionando
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    message: 'Servidor funcionando correctamente',
    timestamp: new Date().toISOString(),
    node_env: process.env.NODE_ENV || 'development',
    supabase_configured: !!(process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY)
  });
});

// Ruta para el favicon
app.get('/favicon.ico', (req, res) => {
  res.sendFile(path.join(publicPath, 'images', 'favicon.ico'));
});

// Ruta para el admin - manejar tanto /admin como /admin/
app.get(['/admin', '/admin/'], (req, res) => {
    console.log('Acceso a ruta de administraci√≥n:', req.path);
    console.log('Cookies en /admin:', req.cookies);
    
    // Si no est√° autenticado, redirigir al login
    if (!req.cookies?.auth_token || req.cookies.auth_token !== 'admin_authenticated') {
        console.log('No autenticado, redirigiendo a login');
        return res.redirect('/admin/login.html');
    }
    
    // Si est√° autenticado, servir el panel de administraci√≥n
    console.log('Usuario autenticado, sirviendo panel de administraci√≥n');
    res.sendFile(path.join(publicPath, 'admin', 'index.html'));
});

// Ruta para los archivos est√°ticos del admin
app.use('/admin', express.static(path.join(publicPath, 'admin'), {
  setHeaders: (res, path) => {
    // Configurar cabeceras de cach√© para archivos est√°ticos
    if (path.match(/\.(js|css|json|xml)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    } else if (path.match(/\.(jpg|jpeg|png|gif|ico|svg|webp|avif|woff|woff2|ttf|eot)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
  }
}));

// Middleware para parsear JSON
app.use(express.json());

// Middleware para parsear cookies
app.use(cookieParser());

// Middleware para verificar autenticaci√≥n
const checkAuth = (req, res, next) => {
    console.log('Ruta solicitada:', req.path);
    console.log('Cookies:', req.cookies);
    
    // Rutas que no requieren autenticaci√≥n
    const publicPaths = [
        '/admin/login',
        '/admin/login.html',
        '/api/admin/login',
        '/api/admin/check-auth'
    ];
    
    // Archivos est√°ticos permitidos sin autenticaci√≥n
    const staticFiles = [
        '/admin/styles.css',
        '/admin/script.js',
        '/admin/favicon.ico'
    ];
    
    // Si es una ruta p√∫blica o archivo est√°tico, continuar
    if (publicPaths.includes(req.path) || 
        staticFiles.includes(req.path) ||
        req.path.startsWith('/components/') ||
        req.path.match(/\.(css|js|png|jpg|jpeg|svg|ico|woff|woff2|ttf|eot)$/)) {
        console.log('Ruta p√∫blica o archivo est√°tico, permitiendo acceso');
        return next();
    }
    
    // Verificar si est√° autenticado
    if (req.cookies?.auth_token === 'admin_authenticated') {
        console.log('Usuario autenticado, permitiendo acceso');
        // Si est√° intentando acceder al login, redirigir al panel de administraci√≥n
        if (req.path === '/admin/login' || req.path === '/admin/login.html') {
            return res.redirect('/admin');
        }
        return next();
    }
    
    // Si no est√° autenticado y est√° intentando acceder a una ruta de administraci√≥n
    if (req.path.startsWith('/admin')) {
        console.log('Acceso no autorizado a ruta de administraci√≥n, redirigiendo a login');
        return res.redirect('/admin/login.html');
    }
    
    // Para otras rutas, continuar
    next();
};

// Aplicar el middleware de autenticaci√≥n
app.use(checkAuth);

// Ruta de login
app.get('/admin/login', (req, res) => {
    res.redirect('/admin/login.html');
});

// Ruta de login (POST)
app.post('/api/admin/login', (req, res) => {
    const { username, password } = req.body;
    console.log('Intento de inicio de sesi√≥n:', { username });
    
    // Verificar credenciales (usuario: admin, contrase√±a: admin123)
    if (username === 'admin' && password === 'admin123') {
        console.log('Credenciales v√°lidas, configurando cookie');
        // Configurar cookie de autenticaci√≥n
        res.cookie('auth_token', 'admin_authenticated', {
            httpOnly: true,
            secure: isProduction,
            sameSite: 'lax',
            maxAge: 24 * 60 * 60 * 1000, // 24 horas
            path: '/'
        });
        
        console.log('Cookie configurada, redirigiendo a /admin');
        return res.json({ success: true, redirect: '/admin' });
    } else {
        console.log('Credenciales inv√°lidas');
        return res.status(401).json({ success: false, message: 'Credenciales inv√°lidas' });
    }
});

// Ruta de logout
app.post('/api/admin/logout', (req, res) => {
    res.clearCookie('auth_token');
    res.json({ success: true });
});

// Ruta de verificaci√≥n de autenticaci√≥n
app.get('/api/admin/check-auth', (req, res) => {
    if (req.cookies?.auth_token) {
        return res.json({ authenticated: true });
    }
    res.json({ authenticated: false });
});

// Ruta del panel de administraci√≥n
app.get('/admin', (req, res) => {

// Ruta para servir el archivo login.html
app.get('/admin/login.html', (req, res) => {
    console.log('Acceso a login.html');
    console.log('Cookies en login.html:', req.cookies);
    
    // Si ya est√° autenticado, redirigir al panel de administraci√≥n
    if (req.cookies?.auth_token === 'admin_authenticated') {
        console.log('Usuario ya autenticado, redirigiendo a /admin');
        return res.redirect('/admin');
    }
    
    console.log('Sirviendo p√°gina de login');
    res.sendFile(path.join(publicPath, 'admin', 'login.html'));
});

// Ruta de login (redirecci√≥n)
app.get('/admin/login', (req, res) => {
    console.log('Redireccionando a /admin/login.html');
    res.redirect('/admin/login.html');
});

app.post('/api/admin/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            console.error('Error al cerrar sesi√≥n:', err);
            return res.status(500).json({ error: 'Error al cerrar sesi√≥n' });
        }
        res.clearCookie('connect.sid');
        res.json({ success: true });
    });
});

// Middleware para proteger rutas de administraci√≥n
app.use('/admin*', (req, res, next) => {
    if (req.path === '/admin/login.html' || req.path === '/admin/login' || req.session.isAuthenticated) {
        return next();
    }
    res.redirect('/admin/login.html');
});

// Ruta espec√≠fica para las p√°ginas de platos (c√≥digo eliminado por ser una ruta duplicada)

// Capturar cualquier otra ruta bajo /admin
app.get('/admin/*', (req, res) => {
    console.log('Ruta de administraci√≥n capturada:', req.path);
    console.log('Cookies en ruta capturada:', req.cookies);
    
    // Si no est√° autenticado, redirigir al login
    if (!req.cookies?.auth_token || req.cookies.auth_token !== 'admin_authenticated') {
        console.log('Acceso no autorizado, redirigiendo a login');
        return res.redirect('/admin/login.html');
    }
    
    // Si est√° autenticado, servir el panel de administraci√≥n
    res.sendFile(path.join(publicPath, 'admin', 'index.html'));
});

// Ruta para los componentes
app.get('/components/*', (req, res) => {
  const filePath = path.join(publicPath, req.path);
  if (fs.existsSync(filePath)) {
    res.sendFile(filePath);
  } else {
    res.status(404).send('Archivo no encontrado');
  }
});

// Configuraci√≥n de multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const dir = path.join(__dirname, 'public', 'images', 'platos');
    if (!fs.existsSync(dir)) { 
      fs.mkdirSync(dir, { recursive: true }); 
    }
    cb(null, dir);
  },
  filename: function (req, file, cb) {
    const titulo = (req.body.titulo || 'plato').toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    cb(null, titulo + path.extname(file.originalname).toLowerCase());
  }
});

// Rutas de la API
app.get('/api/test', (req, res) => {
  res.json({ message: '¬°API funcionando correctamente con Supabase!' });
});

// Middleware para log de solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  if ((req.method === 'POST' || req.method === 'PUT') && req.path === '/api/platos') {
    console.log('=== INICIO DE SOLICITUD', req.method, req.path, '===');
    console.log('Headers:', req.headers);
    console.log('Body recibido:', req.body);
    console.log('Archivo recibido:', req.file ? 'S√≠' : 'No');
  }
  next();
});

// Ruta para crear un nuevo plato
app.post('/api/platos', upload.single('imagen'), async (req, res) => {
  console.log('=== INICIO DE SOLICITUD POST /api/platos ===');
  console.log('Headers:', req.headers);
  
  // Mostrar los campos del body recibidos directamente
  console.log('Body recibido (raw):', req.body);
  
  // Si hay un archivo, mostrarlo
  console.log('Archivo recibido:', req.file ? 'S√≠' : 'No');
  
  try {
    // Procesar la imagen si se subi√≥
    let imagen_url = null;
    
    if (req.file) {
      try {
        console.log('Procesando imagen...');
        const fileExt = req.file.originalname.split('.').pop();
        const fileName = `${Date.now()}.${fileExt}`;
        // Usar solo el nombre del archivo, sin la carpeta 'platos' ya que ya est√° en el bucket
        const filePath = fileName;

        console.log('Subiendo imagen a Supabase Storage...');
        const { error: uploadError } = await supabase.storage
          .from('platos')
          .upload(filePath, req.file.buffer, {
            contentType: req.file.mimetype,
            upsert: false,
            cacheControl: '3600'
          });

        if (uploadError) {
          console.error('Error al subir la imagen a Supabase:', uploadError);
          return res.status(500).json({ 
            error: 'Error al subir la imagen',
            details: uploadError.message 
          });
        }

        // Obtener la URL p√∫blica de la imagen
        const { data: { publicUrl } } = supabase.storage
          .from('platos')
          .getPublicUrl(filePath);

        console.log('Imagen subida correctamente. URL:', publicUrl);
        // Asegurarse de que la URL no tenga 'platos' duplicado
        imagen_url = publicUrl.replace('/platos/platos/', '/platos/');
      } catch (uploadError) {
        console.error('Error al procesar la imagen:', uploadError);
        return res.status(500).json({ 
          error: 'Error al procesar la imagen',
          details: uploadError.message 
        });
      }
    }
    
    // Parsear los campos del formulario
    let titulo, descripcion, precio, activo, id;
    
    // Mostrar los campos recibidos en el body
    console.log('Campos recibidos en el body:');
    for (let key in req.body) {
      console.log(`- ${key}:`, req.body[key]);
    }
    
    // Usar body-parser para analizar el cuerpo de la solicitud
    titulo = req.body.titulo ? req.body.titulo.trim() : '';
    descripcion = req.body.descripcion ? req.body.descripcion.trim() : '';
    
    // Intentar obtener el precio de 'precio' o 'valor'
    precio = req.body.precio || req.body.valor;
    
    // Manejar el valor de 'activo' de diferentes formatos
    activo = (
      req.body.activo === true || 
      req.body.activo === 'true' || 
      req.body.activo === '1' || 
      req.body.activo === 'on' ||
      req.body.activo === 1
    );
    
    id = req.body.id;
    
    console.log('Datos recibidos:', { titulo, descripcion, precio, activo, id });
    console.log('Archivo subido:', req.file ? 'S√≠' : 'No');
    
    // Validar campos requeridos
    if (!titulo) {
      console.error('Error: El t√≠tulo es requerido');
      return res.status(400).json({ 
        error: 'El t√≠tulo es requerido',
        field: 'titulo'
      });
    }
    
    // Validar que el precio sea un n√∫mero v√°lido
    if (precio === undefined || precio === null || precio === '') {
      console.error('Error: El precio es requerido');
      return res.status(400).json({ 
        error: 'El precio es requerido',
        field: 'precio'
      });
    }
    
    const platoId = id && id !== 'undefined' ? id : null;
    
    // imagen_url ya est√° establecida por el procesamiento de Supabase Storage
    // Si no se subi√≥ una nueva imagen, usar la existente del body si existe
    if (!imagen_url && req.body.imagen_url) {
      imagen_url = req.body.imagen_url;
      console.log('Usando imagen existente:', imagen_url);
    }
    
    // Validar campos requeridos
    if (!titulo || titulo.trim() === '') {
      return res.status(400).json({ 
        error: 'El t√≠tulo es requerido',
        field: 'titulo'
      });
    }
    
    // Validar que el precio sea un n√∫mero v√°lido
    if (precio === undefined || precio === null || precio === '') {
      console.error('Error: El precio es requerido');
      return res.status(400).json({ 
        error: 'El precio es requerido',
        field: 'precio'
      });
    }

    let precioNumerico;
    try {
      precioNumerico = parseFloat(precio);
      if (isNaN(precioNumerico) || precioNumerico < 0) {
        throw new Error('Precio inv√°lido');
      }
    } catch (error) {
      console.error('Error al procesar el precio:', error);
      return res.status(400).json({ 
        error: 'El precio debe ser un n√∫mero v√°lido mayor o igual a 0',
        field: 'precio'
      });
    }
    
    // Redondear a 2 decimales
    const precioFinal = Math.round(precioNumerico * 100) / 100;
    
    const platoData = { 
      titulo: titulo.trim(), 
      descripcion: (descripcion || '').trim(),
      precio: precioFinal,
      activo: activo === 'on' || activo === true || activo === 'true' || activo === '1' || activo === 1,
      ...(imagen_url ? { imagen_url } : {})
    };
    
    console.log('Datos del plato a guardar:', JSON.stringify(platoData, null, 2));
    
    console.log('Datos procesados del plato:', platoData);
    
    console.log('Datos del plato a guardar:', JSON.stringify(platoData, null, 2));
    
    // Si hay un ID, actualizamos el plato existente
    if (platoId) {
      console.log('Actualizando plato existente con ID:', platoId);
      
      // Verificar si el plato existe
      const { data: existingPlato, error: fetchError } = await supabase
        .from('platos')
        .select('*')
        .eq('id', platoId)
        .single();
        
      if (fetchError || !existingPlato) {
        console.error('Error al buscar el plato existente:', fetchError);
        return res.status(404).json({ 
          error: 'Plato no encontrado',
          details: fetchError?.message
        });
      }
      
      // Actualizar el plato
      const { data, error: updateError } = await supabase
        .from('platos')
        .update(platoData)
        .eq('id', platoId)
        .select()
        .single();
        
      if (updateError) {
        console.error('Error al actualizar en Supabase:', updateError);
        throw updateError;
      }
      
      console.log('Plato actualizado exitosamente:', data);
      return res.json(data);
    } 
    // Si no hay ID, creamos un nuevo plato
    else {
      console.log('Creando nuevo plato...');
      try {
        const { data, error: insertError } = await supabase
          .from('platos')
          .insert([platoData])
          .select()
          .single();
          
        if (insertError) {
          console.error('Error al insertar en Supabase:', insertError);
          throw insertError;
        }
        
        console.log('Nuevo plato creado exitosamente:', data);
        return res.status(201).json(data);
      } catch (dbError) {
        console.error('Error en la base de datos:', dbError);
        throw new Error(`Error al guardar en la base de datos: ${dbError.message}`);
      }
    }
  } catch (error) {
    console.error('‚ùå Error al guardar el plato:', error);
    
    // Si se subi√≥ un archivo pero hubo un error, eliminarlo
    if (req.file) {
      const filePath = path.join(__dirname, 'public', 'images', 'platos', req.file.filename);
      try {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log('Archivo temporal eliminado debido a un error:', filePath);
        }
      } catch (fileError) {
        console.error('Error al eliminar el archivo temporal:', fileError);
      }
    }
    
    // Determinar el c√≥digo de estado adecuado
    const statusCode = error.statusCode || 500;
    
    // Crear objeto de error de respuesta
    const errorResponse = {
      error: error.message || 'Error al guardar el plato',
      details: error.details || error.toString(),
      code: error.code,
      hint: error.hint,
      timestamp: new Date().toISOString()
    };
    
    // Si es un error de validaci√≥n, incluir campos adicionales
    if (error.errors) {
      errorResponse.errors = error.errors;
    }
    
    console.error('Enviando respuesta de error:', JSON.stringify(errorResponse, null, 2));
    
    res.status(statusCode).json(errorResponse);
  } finally {
    console.log('=== FIN DE SOLICITUD POST /api/platos ===\n');
  }
});

// Eliminar un plato
app.delete('/api/platos/:id', async (req, res) => {
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }

    console.log('Eliminando plato con ID:', platoId);
    
    // Primero obtenemos el plato para poder eliminar su imagen si existe
    const { data: plato, error: fetchError } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();

    if (fetchError) throw fetchError;
    
    // Si el plato tiene una imagen, intentamos eliminarla
    if (plato && plato.imagen_url) {
      try {
        const imagePath = path.join(__dirname, 'public', plato.imagen_url);
        if (fs.existsSync(imagePath)) {
          fs.unlinkSync(imagePath);
          console.log('Imagen eliminada:', imagePath);
        }
      } catch (fileError) {
        console.error('Error al eliminar la imagen del plato:', fileError);
        // Continuamos con la eliminaci√≥n del registro aunque falle la eliminaci√≥n de la imagen
      }
    }
    
    // Eliminamos el registro de la base de datos
    const { error: deleteError } = await supabase
      .from('platos')
      .delete()
      .eq('id', platoId);

    if (deleteError) throw deleteError;
    
    console.log('Plato eliminado exitosamente');
    res.status(200).json({ message: 'Plato eliminado correctamente' });
    
  } catch (error) {
    console.error('‚ùå Error al eliminar el plato:', error);
    res.status(500).json({ 
      error: 'Error al eliminar el plato',
      details: error.message 
    });
  }
});

// Actualizar un plato existente
app.put('/api/platos/:id', upload.single('imagen'), async (req, res) => {
  let oldImagePath = null;
  
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }

    console.log('=== INICIO DE ACTUALIZACI√ìN DE PLATO ===');
    console.log('Plato ID:', platoId);
    console.log('Cuerpo de la solicitud:', req.body);
    console.log('Archivo recibido:', req.file);
    
    // Obtener el plato actual primero
    const { data: existingPlato, error: fetchError } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();
      
    if (fetchError) {
      console.error('Error al obtener el plato existente:', fetchError);
      throw fetchError;
    }
    
    console.log('Plato existente:', existingPlato);
    
    // Determinar si es solo actualizaci√≥n de estado activo/desactivo
    const isOnlyUpdatingActive = req.body.activo !== undefined && Object.keys(req.body).length === 1;
    
    // Inicializar datos del plato con valores existentes
    let platoData = { ...existingPlato };
    
    // Actualizar solo los campos que se est√°n enviando
    if (req.body.titulo !== undefined) platoData.titulo = req.body.titulo;
    if (req.body.descripcion !== undefined) platoData.descripcion = req.body.descripcion;
    
    // Manejar el precio
    if (req.body.precio !== undefined) {
      const precio = parseFloat(req.body.precio);
      if (isNaN(precio)) {
        throw new Error('El precio debe ser un n√∫mero v√°lido');
      }
      platoData.precio = precio;
    }
    
    // Manejar el estado activo
    if (req.body.activo !== undefined) {
      platoData.activo = (req.body.activo === 'on' || req.body.activo === true || req.body.activo === 'true');
    }
    
    console.log('Datos actualizados del plato:', platoData);
    
    // Si es solo actualizaci√≥n de estado activo/desactivo, actualizar solo ese campo
    if (isOnlyUpdatingActive) {
      platoData.activo = req.body.activo === true || req.body.activo === 'true';
      console.log('Actualizando solo el estado activo a:', platoData.activo);
      
      // Actualizar solo el campo activo en la base de datos
      const { data: updatedPlato, error: updateError } = await supabase
        .from('platos')
        .update({ 
          activo: platoData.activo
        })
        .eq('id', platoId)
        .select()
        .single();
        
      if (updateError) throw updateError;
      
      console.log('Estado activo actualizado exitosamente:', updatedPlato);
      return res.json(updatedPlato);
    }
    
    // Manejo de la imagen
    if (req.file) {
      // Si se sube una nueva imagen
      platoData.imagen_url = '/images/platos/' + req.file.filename;
      
      // Guardar la ruta de la imagen anterior para eliminarla despu√©s
      if (existingPlato && existingPlato.imagen_url) {
        oldImagePath = path.join(__dirname, 'public', existingPlato.imagen_url);
      }
    } else if (req.body.imagen_url === '' || req.body.imagen_url === null || req.body.imagen_url === 'null') {
      // Si se env√≠a una cadena vac√≠a o null, eliminar la imagen
      platoData.imagen_url = null;
      
      // Guardar la ruta de la imagen anterior para eliminarla despu√©s
      if (existingPlato && existingPlato.imagen_url) {
        oldImagePath = path.join(__dirname, 'public', existingPlato.imagen_url);
      }
    }
    // Si no hay cambios en la imagen, mantener la existente
    
    console.log('Actualizando plato con datos:', platoData);
    
    console.log('Intentando actualizar en Supabase con datos:', platoData);
    
    // Preparar los datos para actualizar
    const updateData = {
      titulo: platoData.titulo,
      descripcion: platoData.descripcion,
      precio: platoData.precio,
      activo: platoData.activo
    };
    
    // Si hay una nueva URL de imagen, incluirla
    if (platoData.imagen_url !== undefined) {
      updateData.imagen_url = platoData.imagen_url;
    }
    
    console.log('Actualizando plato con datos:', updateData);
    
    // Actualizar el plato en la base de datos
    const { data: updatedPlato, error: updateError } = await supabase
      .from('platos')
      .update(updateData)
      .eq('id', platoId)
      .select()
      .single();
      
    if (updateError) {
      console.error('Error al actualizar en Supabase:', {
        message: updateError.message,
        code: updateError.code,
        details: updateError.details,
        hint: updateError.hint,
        status: updateError.status
      });
      throw updateError;
    }
    
    // Si la actualizaci√≥n fue exitosa y hay una imagen anterior, eliminarla
    if (oldImagePath && fs.existsSync(oldImagePath)) {
      try {
        fs.unlinkSync(oldImagePath);
        console.log('Imagen anterior eliminada:', oldImagePath);
      } catch (fileError) {
        console.error('Error al eliminar la imagen anterior:', fileError);
        // No fallamos la operaci√≥n si no se puede eliminar la imagen anterior
      }
    }
    
    console.log('Plato actualizado exitosamente:', updatedPlato);
    res.json(updatedPlato);
    
  } catch (error) {
    console.error('‚ùå Error al actualizar el plato:', error);
    
    // Si hubo un error y se subi√≥ un archivo, eliminarlo
    if (req.file) {
      const tempPath = path.join(__dirname, 'public', 'images', 'platos', req.file.filename);
      if (fs.existsSync(tempPath)) {
        try {
          fs.unlinkSync(tempPath);
          console.log('Archivo temporal eliminado debido a un error:', tempPath);
        } catch (fileError) {
          console.error('Error al eliminar el archivo temporal:', fileError);
        }
      }
    }
    
    res.status(500).json({ 
      error: 'Error al actualizar el plato',
      details: error.message 
    });
  }
});

// ============================================  
// ENDPOINT PARA FORMULARIO DE CONTACTO  
// ============================================  
app.post('/api/contacto', express.json(), async (req, res) => {  
  // Debug: Verificar variables de entorno
  console.log('üîç Verificando variables SMTP:');
  console.log('SMTP_HOST:', process.env.SMTP_HOST);
  console.log('SMTP_PORT:', process.env.SMTP_PORT);
  console.log('SMTP_USER:', process.env.SMTP_USER);
  console.log('SMTP_PASS:', process.env.SMTP_PASS ? '***' + process.env.SMTP_PASS.slice(-4) : 'NO DEFINIDA');
  
  try {  
    const { name, email, phone, subject, message } = req.body;  
      
    // Validar campos requeridos  
    if (!name || !email || !message) {  
      return res.status(400).json({   
        error: 'Nombre, email y mensaje son requeridos'   
      });  
    }  
  
    // Configurar nodemailer con opciones adicionales para cPanel  
    const nodemailer = require('nodemailer');  
    const transporter = nodemailer.createTransport({  
      host: process.env.SMTP_HOST,  
      port: parseInt(process.env.SMTP_PORT),  
      secure: true, // true para puerto 465  
      auth: {  
        user: process.env.SMTP_USER,  
        pass: process.env.SMTP_PASS  
      },  
      tls: {  
        rejectUnauthorized: false, // Importante para algunos servidores cPanel  
        minVersion: 'TLSv1.2'  
      },  
      debug: true, // Activar logs de depuraci√≥n  
      logger: true  
    });  
  
    // Verificar la conexi√≥n antes de enviar  
    await transporter.verify();  
    console.log('‚úÖ Conexi√≥n SMTP verificada correctamente');  
  
    // Configurar el correo  
    const mailOptions = {  
      from: `"Formulario Los Sartenes" <${process.env.SMTP_USER}>`,  
      to: process.env.CONTACT_EMAIL,  
      replyTo: email, // Permite responder directamente al remitente  
      subject: `Nuevo mensaje de contacto: ${subject || 'Sin asunto'}`,  
      html: `  
        <h2>Nuevo mensaje desde el formulario de contacto</h2>  
        <p><strong>Nombre:</strong> ${name}</p>  
        <p><strong>Email:</strong> ${email}</p>  
        <p><strong>Tel√©fono:</strong> ${phone || 'No proporcionado'}</p>  
        <p><strong>Asunto:</strong> ${subject || 'Sin asunto'}</p>  
        <p><strong>Mensaje:</strong></p>  
        <p>${message}</p>  
      `  
    };  
  
    // Enviar el correo  
    const info = await transporter.sendMail(mailOptions);  
    console.log('‚úÖ Correo enviado:', info.messageId);  
      
    res.json({   
      success: true,   
      message: 'Mensaje enviado correctamente'   
    });  
      
  } catch (error) {  
    console.error('‚ùå Error al enviar correo:', error);  
    res.status(500).json({   
      error: 'Error al enviar el mensaje',  
      details: error.message   
    });  
  }  
});

// Test endpoint to verify SMTP connection
app.get('/test-smtp', async (req, res) => {
  const nodemailer = require('nodemailer');
  
  console.log('üîç SMTP Configuration:');
  console.log('Host:', process.env.SMTP_HOST);
  console.log('Port:', process.env.SMTP_PORT);
  console.log('User:', process.env.SMTP_USER);
  
  const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT),
    secure: true,
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS
    },
    tls: {
      rejectUnauthorized: false
    },
    debug: true,
    logger: true
  });

  try {
    // Verify connection configuration
    await transporter.verify();
    console.log('‚úÖ Server is ready to take our messages');
    res.send('SMTP Connection successful!');
  } catch (error) {
    console.error('‚ùå SMTP Connection failed:', error);
    res.status(500).send(`SMTP Connection failed: ${error.message}`);
  }
});

// Obtener un plato por ID
app.get('/api/platos/:id', async (req, res) => {
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }
    
    console.log('Obteniendo plato con ID:', platoId);
    
    const { data: plato, error } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();
      
    if (error) throw error;
    
    if (!plato) {
      return res.status(404).json({ error: 'Plato no encontrado' });
    }
    
    console.log('Plato encontrado:', plato);
    res.json(plato);
    
  } catch (error) {
    console.error('‚ùå Error al obtener el plato:', error);
    res.status(500).json({ 
      error: 'Error al obtener el plato',
      details: error.message 
    });
  }
});

// Obtener todos los platos para el panel de administraci√≥n
app.get('/api/platos', async (req, res) => {
  try {
    console.log('Solicitando lista de platos...');
    
    // Verificar la conexi√≥n con Supabase
    if (!supabase) {
      console.error('Error: Supabase no est√° configurado correctamente');
      return res.status(500).json({ 
        error: 'Error de configuraci√≥n del servidor',
        details: 'Supabase no est√° configurado correctamente'
      });
    }
    
    const { data, error } = await supabase
      .from('platos')
      .select('*')
      .order('id', { ascending: false }); // Ordenar por ID descendente por defecto

    if (error) {
      console.error('Error en la consulta a Supabase:', {
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint
      });
      
      return res.status(500).json({ 
        error: 'Error al consultar la base de datos',
        details: error.message,
        code: error.code
      });
    }
    
    if (!data || !Array.isArray(data)) {
      console.warn('La respuesta de Supabase no es un arreglo:', data);
      return res.json([]);
    }
    
    console.log(`Se encontraron ${data.length} platos`);
    
    // Mapear los campos para el frontend
    const platos = data.map(item => ({
      id: item.id,
      titulo: item.titulo || 'Sin t√≠tulo',
      descripcion: item.descripcion || '',
      valor: item.precio || 0,
      activo: item.activo !== false, // Por defecto true si no est√° definido
      imagen_url: item.imagen_url || ''
    }));
    
    // Asegurarse de que la respuesta sea siempre un arreglo
    return res.json(platos || []);
    
  } catch (error) {
    console.error('‚ùå Error inesperado al cargar platos:', {
      message: error.message,
      stack: error.stack
    });
    
    return res.status(500).json({ 
      error: 'Error inesperado al cargar los platos',
      details: error.message 
    });
  }
});

// Obtener platos activos para la vista p√∫blica
app.get('/api/platos-activos', async (req, res) => {
  try {
    console.log('Solicitando platos activos...');
    
    const { data, error } = await supabase
      .from('platos')
      .select('*')
      .eq('activo', true)
      .order('id', { ascending: false }); // Ordenar por ID descendente para mostrar los m√°s recientes primero

    if (error) {
      console.error('Error en la consulta a Supabase:', error);
      throw error;
    }
    
    if (!data || !Array.isArray(data)) {
      console.warn('La respuesta de Supabase no es un arreglo:', data);
      return res.json([]);
    }
    
    console.log(`Se encontraron ${data.length} platos activos`);
    
    // Mapear los campos para la vista p√∫blica
    const platos = data.map(item => {
      // Asegurar que el valor sea un n√∫mero v√°lido
      let valor = 0;
      if (item.valor !== undefined && item.valor !== null) {
        // Si es un n√∫mero, usarlo directamente
        if (typeof item.valor === 'number') {
          valor = item.valor;
        } 
        // Si es un string, intentar convertirlo a n√∫mero
        else if (typeof item.valor === 'string') {
          // Eliminar cualquier caracter que no sea n√∫mero o punto decimal
          const valorLimpio = item.valor.replace(/[^0-9.]/g, '');
          valor = parseFloat(valorLimpio) || 0;
        }
      }
      
      // Usar el precio si existe, de lo contrario usar el valor
      let precioFinal = 0;
      
      // Si hay un precio definido, usarlo como valor principal
      if (item.precio !== undefined && item.precio !== null) {
          precioFinal = typeof item.precio === 'number' ? 
                      item.precio : 
                      (typeof item.precio === 'string' ? parseFloat(item.precio.replace(/[^0-9.]/g, '')) || 0 : 0);
      } 
      // Si no hay precio pero s√≠ hay valor, usarlo
      else if (valor !== undefined && valor !== null) {
          precioFinal = valor;
      }
      
      // Asegurarse de que el precio sea un n√∫mero v√°lido
      precioFinal = isNaN(precioFinal) ? 0 : precioFinal;
      
      // Crear el objeto de respuesta
      const platoResponse = {
        id: item.id,
        titulo: item.titulo || 'Sin t√≠tulo',
        descripcion: item.descripcion || '',
        precio: precioFinal,
        // Asegurarse de que valor sea igual a precioFinal si precioFinal es diferente de 0
        valor: precioFinal !== 0 ? precioFinal : valor,
        // Mantener el valor como string formateado
        valor_formateado: `$${precioFinal.toFixed(2)}`,
        imagen_url: item.imagen_url || '',
        // Asegurarse de que la URL de la imagen sea accesible en Supabase Storage
        imagen_url_completa: item.imagen_url 
          ? item.imagen_url.includes('supabase.co/storage/') 
            ? item.imagen_url.replace('/platos/platos/', '/platos/') // Corregir doble 'platos' en la URL
            : item.imagen_url.startsWith('http')
              ? item.imagen_url
              : `https://slsdowttijjlwdexzkum.supabase.co/storage/v1/object/public/platos/${item.imagen_url}`
          : ''
      };
      
      console.log('üîç URL de la imagen del plato:', {
        id: item.id,
        titulo: item.titulo,
        imagen_url: item.imagen_url,
        imagen_url_completa: platoResponse.imagen_url_completa
      });
      
      console.log('üìã Datos del plato enviados al frontend:', {
        id: platoResponse.id,
        titulo: platoResponse.titulo,
        precio: platoResponse.precio,
        valor: platoResponse.valor,
        valor_formateado: platoResponse.valor_formateado
      });
      
      return platoResponse;
    });
    
    // Ordenar por ID de forma descendente para mostrar los m√°s recientes primero
    platos.sort((a, b) => b.id - a.id);
    
    res.json(platos);
    
  } catch (error) {
    console.error('‚ùå Error al obtener platos activos:', error);
    res.status(500).json({ 
      error: 'Error al obtener los platos',
      details: error.message 
    });
  }
});

// Ruta para el panel de administraci√≥n
app.get('/admin*', requireAuth, (req, res) => {
  // Try to serve from admin directory first (development)
  const adminPath = path.join(__dirname, 'admin', 'index.html');
  const publicAdminPath = path.join(__dirname, 'public', 'admin', 'index.html');
  
  let fileToServe;
  
  if (fs.existsSync(adminPath)) {
    fileToServe = adminPath;
  } else if (fs.existsSync(publicAdminPath)) {
    fileToServe = publicAdminPath;
  } else {
    return res.status(404).send('Admin panel not found');
  }
  
  console.log(`Sirviendo panel de administraci√≥n desde: ${fileToServe}`);
  res.sendFile(fileToServe, (err) => {
    if (err) {
      console.error('Error al cargar el panel de administraci√≥n:', err);
      res.status(500).send('Error al cargar el panel de administraci√≥n');
    }
  });
});

// Servir archivos est√°ticos para rutas no manejadas por la API
app.use((req, res, next) => {
  // Si la solicitud comienza con /api, devolver 404
  if (req.path.startsWith('/api/')) {
    console.warn(`Ruta API no encontrada: ${req.method} ${req.originalUrl}`);
    return res.status(404).json({ 
      error: 'Endpoint no encontrado',
      path: req.path 
    });
  }
  
  // Si no es una ruta de API, servir archivos est√°ticos
  next();
});

// Ruta para la p√°gina principal
app.get('*', (req, res, next) => {
  // Si es una ruta de API, continuar al siguiente middleware
  if (req.path.startsWith('/api/')) {
    return next();
  }
  
  // Si es un archivo est√°tico, continuar al siguiente middleware
  if (req.path.match(/\.(js|css|json|xml|jpg|jpeg|png|gif|ico|svg|webp|avif|woff|woff2|ttf|eot)$/)) {
    return next();
  }
  
  // Intentar servir el archivo solicitado
  const filePath = path.join(publicPath, req.path);
  
  // Si el archivo existe, servirlo
  if (fs.existsSync(filePath) && !fs.lstatSync(filePath).isDirectory()) {
    return res.sendFile(filePath);
  }
  
  // Si no es un archivo, servir el index.html (para SPA)
  const indexPath = path.join(publicPath, 'index.html');
  
  // Verificar si el archivo index.html existe
  if (!fs.existsSync(indexPath)) {
    console.error('Archivo index.html no encontrado en:', indexPath);
    return res.status(500).send('Error interno del servidor: archivo de inicio no encontrado');
  }
  
  // Enviar el archivo index.html
  res.sendFile(indexPath, (err) => {
    if (err) {
      console.error('Error al cargar la p√°gina principal:', err);
      res.status(500).send('Error al cargar la p√°gina principal');
    }
  });
});

// Middleware para manejo de errores global
app.use((err, req, res, next) => {
  console.error('‚ùå Error no manejado:', err);
  
  // Si los encabezados ya se enviaron, delegar al manejador de errores predeterminado de Express
  if (res.headersSent) {
    return next(err);
  }
  
  // Enviar respuesta de error
  res.status(500).json({
    error: 'Error interno del servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Algo sali√≥ mal',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// Iniciar servidor
const server = app.listen(PORT, '0.0.0.0', () => {
  const host = server.address().address;
  const port = server.address().port;
  const env = process.env.NODE_ENV || 'development';
  
  console.log('='.repeat(60));
  console.log(`üöÄ Servidor iniciado en http://${host}:${port}`);
  console.log(`üåç Entorno: ${env}`);
  console.log(`üîó Supabase: ${process.env.SUPABASE_URL ? '‚úÖ Configurado' : '‚ùå No configurado'}`);
  console.log(`üìÇ Directorio p√∫blico: ${path.join(__dirname, 'public')}`);
  console.log(`üìÇ Directorio de im√°genes: ${path.join(__dirname, 'public', 'images', 'platos')}`);
  console.log('='.repeat(60));
  
  // Verificar directorios importantes
  const dirsToCheck = [
    { path: path.join(__dirname, 'public'), name: 'P√∫blico' },
    { path: path.join(__dirname, 'public', 'images', 'platos'), name: 'Im√°genes de platos' },
    { path: path.join(__dirname, 'admin'), name: 'Admin' }
  ];
  
  dirsToCheck.forEach(dir => {
    const exists = fs.existsSync(dir.path);
    const writable = exists ? (fs.statSync(dir.path).mode & 0o200) !== 0 : false;
    console.log(`üìÇ ${dir.name}: ${exists ? '‚úÖ Existe' : '‚ùå No existe'} ${exists ? (writable ? '(Escritura habilitada)' : '(Solo lectura)') : ''}`);
  });
  
  console.log('='.repeat(60));
});

// Manejo de errores del servidor
server.on('error', (error) => {
  console.error('‚ùå Error del servidor:', error);
  
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof PORT === 'string' ? 'Pipe ' + PORT : 'Port ' + PORT;

  // Mensajes de error amigables
  switch (error.code) {
    case 'EACCES':
      console.error(`‚ùå ${bind} requiere privilegios elevados`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(`‚ùå ${bind} ya est√° en uso`);
      console.log(`üí° Intenta usar un puerto diferente configurando la variable de entorno PORT`);
      process.exit(1);
      break;
    default:
      console.error('‚ùå Error desconocido:', error);
      throw error;
  }
});

// Manejo de cierre limpio
process.on('SIGTERM', () => {
  console.log('\nüîΩ Recibida se√±al SIGTERM. Cerrando servidor...');
  server.close(() => {
    console.log('üëã Servidor cerrado');
    process.exit(0);
  });
  
  // Forzar cierre despu√©s de 5 segundos si es necesario
  setTimeout(() => {
    console.error('‚ö†Ô∏è Forzando cierre del servidor...');
    process.exit(1);
  }, 5000);
});

// Manejo de excepciones no capturadas
process.on('uncaughtException', (error) => {
  console.error('‚ö†Ô∏è Excepci√≥n no capturada:', error);
  // No salir del proceso en desarrollo para permitir la depuraci√≥n
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});

// Manejo de promesas rechazadas no manejadas
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ö†Ô∏è Promesa rechazada no manejada:', reason);
  // Opcional: registrar el error o cerrar recursos
});
