const express = require('express');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const { createClient } = require('@supabase/supabase-js');

// Configuración para Vercel
const isVercel = process.env.VERCEL === '1';

// Configuración de logs
const morgan = require('morgan');
const multer = require('multer');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 9000;
const isProduction = process.env.NODE_ENV === 'production';

// Middleware de logs
app.use(morgan('dev'));

// Middleware para parsear JSON
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configuración de Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

// Configuración de CORS
console.log('Configurando CORS...');
const corsOptions = {
  origin: function (origin, callback) {
    // En producción, permite cualquier origen
    if (process.env.NODE_ENV === 'production') {
      console.log('Permitiendo cualquier origen en producción');
      return callback(null, true);
    }
    
    // En desarrollo, permite localhost y la URL de Vercel
    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:9000',
      'https://sartenes.vercel.app',
      'https://sartenes-git-main-cristhopheryeah113.vercel.app',
      /^\.*\.vercel\.app$/, // Permite cualquier subdominio de vercel.app
      /^http:\/\/localhost:\d+$/ // Permite cualquier puerto localhost
    ];
    
    console.log('Origen de la solicitud:', origin || 'No especificado');
    
    // Si no hay origen (puede pasar con solicitudes no navegador, como Postman)
    if (!origin) {
      console.log('Permitiendo solicitud sin origen (probablemente no es del navegador)');
      return callback(null, true);
    }
    
    // Verificar si el origen está permitido
    const isAllowed = allowedOrigins.some(allowedOrigin => {
      if (typeof allowedOrigin === 'string') {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn('Origen no permitido por CORS:', origin);
      callback(new Error('No permitido por CORS'));
    }
  },
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin', 'Content-Length'],
  exposedHeaders: ['Content-Length', 'X-Foo', 'X-Bar', 'Content-Type'],
  maxAge: 86400 // 24 hours
};

// Aplicar CORS a todas las rutas
console.log('Aplicando middleware CORS...');
app.use(cors(corsOptions));

// Middleware para manejar preflight requests
app.options('*', cors(corsOptions));

// Middleware para loggear todas las solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  console.log('Headers:', req.headers);
  console.log('Body:', req.body);
  next();
});

// Middleware para manejar preflight requests
app.options('*', cors(corsOptions));

// Middleware para agregar headers CORS manualmente si es necesario
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // Responder inmediatamente a las solicitudes OPTIONS
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  next();
});

// Parsear JSON y datos de formulario
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Middleware para log de solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  console.log('Headers:', req.headers);
  console.log('Body:', req.body);
  next();
});

// Configuración de archivos estáticos
const publicPath = path.join(__dirname, 'public');

// Configuración específica para Vercel
if (isVercel) {
  console.log('Ejecutando en Vercel');
  // Asegurarse de que las rutas sean correctas en Vercel
  app.set('trust proxy', 1);
}

// Crear directorio público si no existe
if (!fs.existsSync(publicPath)) {
  fs.mkdirSync(publicPath, { recursive: true });
}

// Configuración para servir archivos estáticos
const staticOptions = {
  setHeaders: (res, path) => {
    // Configurar cabeceras de caché para archivos estáticos
    if (path.match(/\.(js|css|json|xml)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    } else if (path.endsWith('.css')) {
      res.setHeader('Content-Type', 'text/css');
    } else if (path.endsWith('.js')) {
      res.setHeader('Content-Type', 'application/javascript');
    } else if (path.endsWith('.json')) {
      res.setHeader('Content-Type', 'application/json');
    } else if (path.endsWith('.html')) {
      res.setHeader('Content-Type', 'text/html');
    } else if (path.endsWith('.jpg') || path.endsWith('.jpeg')) {
      res.setHeader('Content-Type', 'image/jpeg');
    } else if (path.endsWith('.png')) {
      res.setHeader('Content-Type', 'image/png');
    } else if (path.endsWith('.gif')) {
      res.setHeader('Content-Type', 'image/gif');
    } else if (path.endsWith('.svg')) {
      res.setHeader('Content-Type', 'image/svg+xml');
    } else if (path.endsWith('.woff')) {
      res.setHeader('Content-Type', 'font/woff');
    } else if (path.endsWith('.woff2')) {
      res.setHeader('Content-Type', 'font/woff2');
    } else if (path.endsWith('.ttf')) {
      res.setHeader('Content-Type', 'font/ttf');
    } else if (path.endsWith('.eot')) {
      res.setHeader('Content-Type', 'application/vnd.ms-fontobject');
    }
  }
};

// Servir archivos estáticos desde la carpeta public
app.use(express.static(publicPath, staticOptions));
// Servir archivos estáticos desde la raíz del proyecto para desarrollo
if (!isProduction) {
  app.use(express.static(__dirname, staticOptions));
}

// Configuración de archivos estáticos
                    if (el) el.remove();
                });
                
                // Asegurarse de que el body solo muestre el contenido del plato
                const platoContent = document.getElementById('plato-content');
                if (platoContent) {
                    document.body.innerHTML = platoContent.innerHTML;
                }
            });
        </script>
    </body>
    </html>`;
    
    return res.send(platoContent);
  }
  
  res.status(404).send('Página no encontrada');
});

// Ruta para servir archivos CSS y JS desde la raíz
app.get('/*.(css|js|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)', (req, res) => {
  const filePath = path.join(publicPath, req.path);
  if (fs.existsSync(filePath)) {
    return res.sendFile(filePath);
  }
  res.status(404).end();
});

// En desarrollo, servir archivos estáticos desde la raíz
if (!isProduction) {
  app.use(express.static(__dirname, staticOptions));
}

// Ruta para verificar que el servidor está funcionando
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    message: 'Servidor funcionando correctamente',
    timestamp: new Date().toISOString(),
    node_env: process.env.NODE_ENV || 'development',
    supabase_configured: !!(process.env.SUPABASE_URL && process.env.SUPABASE_ANON_KEY)
  });
});

// Ruta para el favicon
app.get('/favicon.ico', (req, res) => {
  res.sendFile(path.join(publicPath, 'images', 'favicon.ico'));
});

// Ruta para el admin - manejar tanto /admin como /admin/
app.get(['/admin', '/admin/'], (req, res) => {
  res.sendFile(path.join(publicPath, 'admin', 'index.html'));
});

// Ruta para los archivos estáticos del admin
app.use('/admin', express.static(path.join(publicPath, 'admin'), {
  setHeaders: (res, path) => {
    // Configurar cabeceras de caché para archivos estáticos
    if (path.match(/\.(js|css|json|xml)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    } else if (path.match(/\.(jpg|jpeg|png|gif|ico|svg|webp|avif|woff|woff2|ttf|eot)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
  }
}));

// Ruta específica para las páginas de platos
app.get('/menu/platos/:plato', (req, res) => {
  // Asegurarse de que el nombre del archivo termine con .html
  const platoName = req.params.plato.endsWith('.html') 
    ? req.params.plato 
    : `${req.params.plato}.html`;
    
  const platoFile = path.join(publicPath, 'menu', 'platos', platoName);
  console.log(`Intentando servir: ${platoFile}`);
  
  // Verificar si el archivo existe
  if (fs.existsSync(platoFile)) {
    return res.sendFile(platoFile);
  }
  
  // Si el archivo no existe, devolver 404
  console.error(`Archivo no encontrado: ${platoFile}`);
  res.status(404).send('Página no encontrada');
});

// Capturar cualquier otra ruta bajo /admin y servir el index.html
app.get('/admin/*', (req, res) => {
  res.sendFile(path.join(publicPath, 'admin', 'index.html'));
});

// Ruta para los componentes
app.get('/components/*', (req, res) => {
  const filePath = path.join(publicPath, req.path);
  if (fs.existsSync(filePath)) {
    res.sendFile(filePath);
  } else {
    res.status(404).send('Archivo no encontrado');
  }
});

// Configuración de multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const dir = path.join(__dirname, 'public', 'images', 'platos');
    if (!fs.existsSync(dir)) { 
      fs.mkdirSync(dir, { recursive: true }); 
    }
    cb(null, dir);
  },
  filename: function (req, file, cb) {
    const titulo = (req.body.titulo || 'plato').toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    cb(null, titulo + path.extname(file.originalname).toLowerCase());
  }
});

const upload = multer({ storage: storage });

// Rutas de la API
app.get('/api/test', (req, res) => {
  res.json({ message: '¡API funcionando correctamente con Supabase!' });
});

// Middleware para log de solicitudes
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  if ((req.method === 'POST' || req.method === 'PUT') && req.path === '/api/platos') {
    console.log('=== INICIO DE SOLICITUD', req.method, req.path, '===');
    console.log('Headers:', req.headers);
    console.log('Body recibido:', req.body);
    console.log('Archivo recibido:', req.file ? 'Sí' : 'No');
  }
  next();
});

// Ruta para crear un nuevo plato
app.post('/api/platos', upload.single('imagen'), async (req, res) => {
  console.log('=== INICIO DE SOLICITUD POST /api/platos ===');
  console.log('Cuerpo de la solicitud:', req.body);
  console.log('Archivo subido:', req.file);
  console.log('=== INICIO DE SOLICITUD POST /api/platos ===');
  
  try {
    const { titulo, descripcion, precio, activo, id } = req.body;
    console.log('Datos recibidos:', { titulo, descripcion, precio, activo, id });
    
    // Validar campos requeridos
    if (!titulo || titulo.trim() === '') {
      console.error('Error: El título es requerido');
      return res.status(400).json({ 
        error: 'El título es requerido',
        field: 'titulo'
      });
    }
    
    if (!precio && precio !== 0) {
      console.error('Error: El precio es requerido');
      return res.status(400).json({ 
        error: 'El precio es requerido',
        field: 'precio'
      });
    }
    
    const platoId = id && id !== 'undefined' ? id : null;
    
    // Manejo de la imagen
    let imagen_url = req.body.imagen_url || '';
    if (req.file) {
      imagen_url = '/images/platos/' + req.file.filename;
      console.log('Nueva imagen subida:', imagen_url);
    }
    
    // Validar campos requeridos
    if (!titulo || titulo.trim() === '') {
      return res.status(400).json({ 
        error: 'El título es requerido',
        field: 'titulo'
      });
    }
    
    // Validar que el precio sea un número válido
    const precioNumerico = parseFloat(precio);
    if (isNaN(precioNumerico) || precioNumerico < 0) {
      return res.status(400).json({ 
        error: 'El precio debe ser un número válido mayor o igual a 0',
        field: 'precio'
      });
    }
    
    // Redondear a 2 decimales
    const precioFinal = Math.round(precioNumerico * 100) / 100;
    
    const platoData = { 
      titulo: titulo.trim(), 
      descripcion: (descripcion || '').trim(),
      precio: precioFinal,
      activo: activo === 'on' || activo === true || activo === 'true' || activo === '1' || activo === 1,
      ...(imagen_url ? { imagen_url } : {})
    };
    
    console.log('Datos del plato a guardar:', JSON.stringify(platoData, null, 2));
    
    console.log('Datos procesados del plato:', platoData);
    
    console.log('Datos del plato a guardar:', JSON.stringify(platoData, null, 2));
    
    // Si hay un ID, actualizamos el plato existente
    if (platoId) {
      console.log('Actualizando plato existente con ID:', platoId);
      
      // Verificar si el plato existe
      const { data: existingPlato, error: fetchError } = await supabase
        .from('platos')
        .select('*')
        .eq('id', platoId)
        .single();
        
      if (fetchError || !existingPlato) {
        console.error('Error al buscar el plato existente:', fetchError);
        return res.status(404).json({ 
          error: 'Plato no encontrado',
          details: fetchError?.message
        });
      }
      
      // Actualizar el plato
      const { data, error: updateError } = await supabase
        .from('platos')
        .update(platoData)
        .eq('id', platoId)
        .select()
        .single();
        
      if (updateError) {
        console.error('Error al actualizar en Supabase:', updateError);
        throw updateError;
      }
      
      console.log('Plato actualizado exitosamente:', data);
      return res.json(data);
    } 
    // Si no hay ID, creamos un nuevo plato
    else {
      console.log('Creando nuevo plato...');
      try {
        const { data, error: insertError } = await supabase
          .from('platos')
          .insert([platoData])
          .select()
          .single();
          
        if (insertError) {
          console.error('Error al insertar en Supabase:', insertError);
          throw insertError;
        }
        
        console.log('Nuevo plato creado exitosamente:', data);
        return res.status(201).json(data);
      } catch (dbError) {
        console.error('Error en la base de datos:', dbError);
        throw new Error(`Error al guardar en la base de datos: ${dbError.message}`);
      }
    }
  } catch (error) {
    console.error('❌ Error al guardar el plato:', error);
    
    // Si se subió un archivo pero hubo un error, eliminarlo
    if (req.file) {
      const filePath = path.join(__dirname, 'public', 'images', 'platos', req.file.filename);
      try {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log('Archivo temporal eliminado debido a un error:', filePath);
        }
      } catch (fileError) {
        console.error('Error al eliminar el archivo temporal:', fileError);
      }
    }
    
    // Determinar el código de estado adecuado
    const statusCode = error.statusCode || 500;
    
    // Crear objeto de error de respuesta
    const errorResponse = {
      error: error.message || 'Error al guardar el plato',
      details: error.details || error.toString(),
      code: error.code,
      hint: error.hint,
      timestamp: new Date().toISOString()
    };
    
    // Si es un error de validación, incluir campos adicionales
    if (error.errors) {
      errorResponse.errors = error.errors;
    }
    
    console.error('Enviando respuesta de error:', JSON.stringify(errorResponse, null, 2));
    
    res.status(statusCode).json(errorResponse);
  } finally {
    console.log('=== FIN DE SOLICITUD POST /api/platos ===\n');
  }
});

// Eliminar un plato
app.delete('/api/platos/:id', async (req, res) => {
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }

    console.log('Eliminando plato con ID:', platoId);
    
    // Primero obtenemos el plato para poder eliminar su imagen si existe
    const { data: plato, error: fetchError } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();

    if (fetchError) throw fetchError;
    
    // Si el plato tiene una imagen, intentamos eliminarla
    if (plato && plato.imagen_url) {
      try {
        const imagePath = path.join(__dirname, 'public', plato.imagen_url);
        if (fs.existsSync(imagePath)) {
          fs.unlinkSync(imagePath);
          console.log('Imagen eliminada:', imagePath);
        }
      } catch (fileError) {
        console.error('Error al eliminar la imagen del plato:', fileError);
        // Continuamos con la eliminación del registro aunque falle la eliminación de la imagen
      }
    }
    
    // Eliminamos el registro de la base de datos
    const { error: deleteError } = await supabase
      .from('platos')
      .delete()
      .eq('id', platoId);

    if (deleteError) throw deleteError;
    
    console.log('Plato eliminado exitosamente');
    res.status(200).json({ message: 'Plato eliminado correctamente' });
    
  } catch (error) {
    console.error('❌ Error al eliminar el plato:', error);
    res.status(500).json({ 
      error: 'Error al eliminar el plato',
      details: error.message 
    });
  }
});

// Actualizar un plato existente
app.put('/api/platos/:id', upload.single('imagen'), async (req, res) => {
  let oldImagePath = null;
  
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }

    console.log('=== INICIO DE ACTUALIZACIÓN DE PLATO ===');
    console.log('Plato ID:', platoId);
    console.log('Cuerpo de la solicitud:', req.body);
    console.log('Archivo recibido:', req.file);
    
    // Obtener el plato actual primero
    const { data: existingPlato, error: fetchError } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();
      
    if (fetchError) {
      console.error('Error al obtener el plato existente:', fetchError);
      throw fetchError;
    }
    
    console.log('Plato existente:', existingPlato);
    
    // Determinar si es solo actualización de estado activo/desactivo
    const isOnlyUpdatingActive = req.body.activo !== undefined && Object.keys(req.body).length === 1;
    
    // Inicializar datos del plato con valores existentes
    let platoData = { ...existingPlato };
    
    // Actualizar solo los campos que se están enviando
    if (req.body.titulo !== undefined) platoData.titulo = req.body.titulo;
    if (req.body.descripcion !== undefined) platoData.descripcion = req.body.descripcion;
    
    // Manejar el precio
    if (req.body.precio !== undefined) {
      const precio = parseFloat(req.body.precio);
      if (isNaN(precio)) {
        throw new Error('El precio debe ser un número válido');
      }
      platoData.precio = precio;
    }
    
    // Manejar el estado activo
    if (req.body.activo !== undefined) {
      platoData.activo = (req.body.activo === 'on' || req.body.activo === true || req.body.activo === 'true');
    }
    
    console.log('Datos actualizados del plato:', platoData);
    
    // Si es solo actualización de estado activo/desactivo, actualizar solo ese campo
    if (isOnlyUpdatingActive) {
      platoData.activo = req.body.activo === true || req.body.activo === 'true';
      console.log('Actualizando solo el estado activo a:', platoData.activo);
      
      // Actualizar solo el campo activo en la base de datos
      const { data: updatedPlato, error: updateError } = await supabase
        .from('platos')
        .update({ 
          activo: platoData.activo
        })
        .eq('id', platoId)
        .select()
        .single();
        
      if (updateError) throw updateError;
      
      console.log('Estado activo actualizado exitosamente:', updatedPlato);
      return res.json(updatedPlato);
    }
    
    // Manejo de la imagen
    if (req.file) {
      // Si se sube una nueva imagen
      platoData.imagen_url = '/images/platos/' + req.file.filename;
      
      // Guardar la ruta de la imagen anterior para eliminarla después
      if (existingPlato && existingPlato.imagen_url) {
        oldImagePath = path.join(__dirname, 'public', existingPlato.imagen_url);
      }
    } else if (req.body.imagen_url === '' || req.body.imagen_url === null || req.body.imagen_url === 'null') {
      // Si se envía una cadena vacía o null, eliminar la imagen
      platoData.imagen_url = null;
      
      // Guardar la ruta de la imagen anterior para eliminarla después
      if (existingPlato && existingPlato.imagen_url) {
        oldImagePath = path.join(__dirname, 'public', existingPlato.imagen_url);
      }
    }
    // Si no hay cambios en la imagen, mantener la existente
    
    console.log('Actualizando plato con datos:', platoData);
    
    console.log('Intentando actualizar en Supabase con datos:', platoData);
    
    // Preparar los datos para actualizar
    const updateData = {
      titulo: platoData.titulo,
      descripcion: platoData.descripcion,
      precio: platoData.precio,
      activo: platoData.activo
    };
    
    // Si hay una nueva URL de imagen, incluirla
    if (platoData.imagen_url !== undefined) {
      updateData.imagen_url = platoData.imagen_url;
    }
    
    console.log('Actualizando plato con datos:', updateData);
    
    // Actualizar el plato en la base de datos
    const { data: updatedPlato, error: updateError } = await supabase
      .from('platos')
      .update(updateData)
      .eq('id', platoId)
      .select()
      .single();
      
    if (updateError) {
      console.error('Error al actualizar en Supabase:', {
        message: updateError.message,
        code: updateError.code,
        details: updateError.details,
        hint: updateError.hint,
        status: updateError.status
      });
      throw updateError;
    }
    
    // Si la actualización fue exitosa y hay una imagen anterior, eliminarla
    if (oldImagePath && fs.existsSync(oldImagePath)) {
      try {
        fs.unlinkSync(oldImagePath);
        console.log('Imagen anterior eliminada:', oldImagePath);
      } catch (fileError) {
        console.error('Error al eliminar la imagen anterior:', fileError);
        // No fallamos la operación si no se puede eliminar la imagen anterior
      }
    }
    
    console.log('Plato actualizado exitosamente:', updatedPlato);
    res.json(updatedPlato);
    
  } catch (error) {
    console.error('❌ Error al actualizar el plato:', error);
    
    // Si hubo un error y se subió un archivo, eliminarlo
    if (req.file) {
      const tempPath = path.join(__dirname, 'public', 'images', 'platos', req.file.filename);
      if (fs.existsSync(tempPath)) {
        try {
          fs.unlinkSync(tempPath);
          console.log('Archivo temporal eliminado debido a un error:', tempPath);
        } catch (fileError) {
          console.error('Error al eliminar el archivo temporal:', fileError);
        }
      }
    }
    
    res.status(500).json({ 
      error: 'Error al actualizar el plato',
      details: error.message 
    });
  }
});

// Obtener un plato por ID
app.get('/api/platos/:id', async (req, res) => {
  try {
    const platoId = req.params.id;
    if (!platoId) {
      return res.status(400).json({ error: 'Se requiere el ID del plato' });
    }
    
    console.log('Obteniendo plato con ID:', platoId);
    
    const { data: plato, error } = await supabase
      .from('platos')
      .select('*')
      .eq('id', platoId)
      .single();
      
    if (error) throw error;
    
    if (!plato) {
      return res.status(404).json({ error: 'Plato no encontrado' });
    }
    
    console.log('Plato encontrado:', plato);
    res.json(plato);
    
  } catch (error) {
    console.error('❌ Error al obtener el plato:', error);
    res.status(500).json({ 
      error: 'Error al obtener el plato',
      details: error.message 
    });
  }
});

// Obtener todos los platos para el panel de administración
app.get('/api/platos', async (req, res) => {
  try {
    console.log('Solicitando lista de platos...');
    
    // Verificar la conexión con Supabase
    if (!supabase) {
      console.error('Error: Supabase no está configurado correctamente');
      return res.status(500).json({ 
        error: 'Error de configuración del servidor',
        details: 'Supabase no está configurado correctamente'
      });
    }
    
    const { data, error } = await supabase
      .from('platos')
      .select('*')
      .order('id', { ascending: false }); // Ordenar por ID descendente por defecto

    if (error) {
      console.error('Error en la consulta a Supabase:', {
        message: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint
      });
      
      return res.status(500).json({ 
        error: 'Error al consultar la base de datos',
        details: error.message,
        code: error.code
      });
    }
    
    if (!data || !Array.isArray(data)) {
      console.warn('La respuesta de Supabase no es un arreglo:', data);
      return res.json([]);
    }
    
    console.log(`Se encontraron ${data.length} platos`);
    
    // Mapear los campos para el frontend
    const platos = data.map(item => ({
      id: item.id,
      titulo: item.titulo || 'Sin título',
      descripcion: item.descripcion || '',
      valor: item.precio || 0,
      activo: item.activo !== false, // Por defecto true si no está definido
      imagen_url: item.imagen_url || ''
    }));
    
    // Asegurarse de que la respuesta sea siempre un arreglo
    return res.json(platos || []);
    
  } catch (error) {
    console.error('❌ Error inesperado al cargar platos:', {
      message: error.message,
      stack: error.stack
    });
    
    return res.status(500).json({ 
      error: 'Error inesperado al cargar los platos',
      details: error.message 
    });
  }
});

// Obtener platos activos para la vista pública
app.get('/api/platos-activos', async (req, res) => {
  try {
    console.log('Solicitando platos activos...');
    
    const { data, error } = await supabase
      .from('platos')
      .select('*')
      .eq('activo', true)
      .order('id', { ascending: false }); // Ordenar por ID descendente para mostrar los más recientes primero

    if (error) {
      console.error('Error en la consulta a Supabase:', error);
      throw error;
    }
    
    if (!data || !Array.isArray(data)) {
      console.warn('La respuesta de Supabase no es un arreglo:', data);
      return res.json([]);
    }
    
    console.log(`Se encontraron ${data.length} platos activos`);
    
    // Mapear los campos para la vista pública
    const platos = data.map(item => {
      // Asegurar que el valor sea un número válido
      let valor = 0;
      if (item.valor !== undefined && item.valor !== null) {
        // Si es un número, usarlo directamente
        if (typeof item.valor === 'number') {
          valor = item.valor;
        } 
        // Si es un string, intentar convertirlo a número
        else if (typeof item.valor === 'string') {
          // Eliminar cualquier caracter que no sea número o punto decimal
          const valorLimpio = item.valor.replace(/[^0-9.]/g, '');
          valor = parseFloat(valorLimpio) || 0;
        }
      }
      
      // Usar el precio si existe, de lo contrario usar el valor
      let precioFinal = 0;
      
      // Si hay un precio definido, usarlo como valor principal
      if (item.precio !== undefined && item.precio !== null) {
          precioFinal = typeof item.precio === 'number' ? 
                      item.precio : 
                      (typeof item.precio === 'string' ? parseFloat(item.precio.replace(/[^0-9.]/g, '')) || 0 : 0);
      } 
      // Si no hay precio pero sí hay valor, usarlo
      else if (valor !== undefined && valor !== null) {
          precioFinal = valor;
      }
      
      // Asegurarse de que el precio sea un número válido
      precioFinal = isNaN(precioFinal) ? 0 : precioFinal;
      
      // Crear el objeto de respuesta
      const platoResponse = {
        id: item.id,
        titulo: item.titulo || 'Sin título',
        descripcion: item.descripcion || '',
        precio: precioFinal,
        // Asegurarse de que valor sea igual a precioFinal si precioFinal es diferente de 0
        valor: precioFinal !== 0 ? precioFinal : valor,
        // Mantener el valor como string formateado
        valor_formateado: `$${precioFinal.toFixed(2)}`,
        imagen_url: item.imagen_url || '',
        // Asegurarse de que la URL de la imagen sea accesible
        imagen_url_completa: item.imagen_url 
          ? item.imagen_url.startsWith('http') 
            ? item.imagen_url 
            : `${req.protocol}://${req.get('host')}${item.imagen_url}`
          : ''
      };
      
      console.log('📋 Datos del plato enviados al frontend:', {
        id: platoResponse.id,
        titulo: platoResponse.titulo,
        precio: platoResponse.precio,
        valor: platoResponse.valor,
        valor_formateado: platoResponse.valor_formateado
      });
      
      return platoResponse;
    });
    
    // Ordenar por ID de forma descendente para mostrar los más recientes primero
    platos.sort((a, b) => b.id - a.id);
    
    res.json(platos);
    
  } catch (error) {
    console.error('❌ Error al obtener platos activos:', error);
    res.status(500).json({ 
      error: 'Error al obtener los platos',
      details: error.message 
    });
  }
});

// Ruta para el panel de administración
app.get('/admin*', (req, res) => {
  // Try to serve from admin directory first (development)
  const adminPath = path.join(__dirname, 'admin', 'index.html');
  const publicAdminPath = path.join(__dirname, 'public', 'admin', 'index.html');
  
  // Check if the file exists in either location
  const fileToServe = fs.existsSync(publicAdminPath) ? publicAdminPath : 
                     fs.existsSync(adminPath) ? adminPath : null;
  
  if (!fileToServe) {
    console.error('No se pudo encontrar el archivo del panel de administración en ninguna ubicación');
    return res.status(404).send('Panel de administración no encontrado');
  }
  
  console.log(`Sirviendo panel de administración desde: ${fileToServe}`);
  res.sendFile(fileToServe, (err) => {
    if (err) {
      console.error('Error al cargar el panel de administración:', err);
      res.status(500).send('Error al cargar el panel de administración');
    }
  });
});

// Servir archivos estáticos para rutas no manejadas por la API
app.use((req, res, next) => {
  // Si la solicitud comienza con /api, devolver 404
  if (req.path.startsWith('/api/')) {
    console.warn(`Ruta API no encontrada: ${req.method} ${req.originalUrl}`);
    return res.status(404).json({ 
      error: 'Endpoint no encontrado',
      path: req.path 
    });
  }
  
  // Si no es una ruta de API, servir archivos estáticos
  next();
});

// Ruta para la página principal
app.get('*', (req, res, next) => {
  // Si es una ruta de API, continuar al siguiente middleware
  if (req.path.startsWith('/api/')) {
    return next();
  }
  
  // Si es un archivo estático, continuar al siguiente middleware
  if (req.path.match(/\.(js|css|json|xml|jpg|jpeg|png|gif|ico|svg|webp|avif|woff|woff2|ttf|eot)$/)) {
    return next();
  }
  
  // Intentar servir el archivo solicitado
  const filePath = path.join(publicPath, req.path);
  
  // Si el archivo existe, servirlo
  if (fs.existsSync(filePath) && !fs.lstatSync(filePath).isDirectory()) {
    return res.sendFile(filePath);
  }
  
  // Si no es un archivo, servir el index.html (para SPA)
  const indexPath = path.join(publicPath, 'index.html');
  
  // Verificar si el archivo index.html existe
  if (!fs.existsSync(indexPath)) {
    console.error('Archivo index.html no encontrado en:', indexPath);
    return res.status(500).send('Error interno del servidor: archivo de inicio no encontrado');
  }
  
  // Enviar el archivo index.html
  res.sendFile(indexPath, (err) => {
    if (err) {
      console.error('Error al cargar la página principal:', err);
      res.status(500).send('Error al cargar la página principal');
    }
  });
});

// Middleware para manejo de errores global
app.use((err, req, res, next) => {
  console.error('❌ Error no manejado:', err);
  
  // Si los encabezados ya se enviaron, delegar al manejador de errores predeterminado de Express
  if (res.headersSent) {
    return next(err);
  }
  
  // Enviar respuesta de error
  res.status(500).json({
    error: 'Error interno del servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Algo salió mal',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// Iniciar servidor
const server = app.listen(PORT, '0.0.0.0', () => {
  const host = server.address().address;
  const port = server.address().port;
  const env = process.env.NODE_ENV || 'development';
  
  console.log('='.repeat(60));
  console.log(`🚀 Servidor iniciado en http://${host}:${port}`);
  console.log(`🌍 Entorno: ${env}`);
  console.log(`🔗 Supabase: ${process.env.SUPABASE_URL ? '✅ Configurado' : '❌ No configurado'}`);
  console.log(`📂 Directorio público: ${path.join(__dirname, 'public')}`);
  console.log(`📂 Directorio de imágenes: ${path.join(__dirname, 'public', 'images', 'platos')}`);
  console.log('='.repeat(60));
  
  // Verificar directorios importantes
  const dirsToCheck = [
    { path: path.join(__dirname, 'public'), name: 'Público' },
    { path: path.join(__dirname, 'public', 'images', 'platos'), name: 'Imágenes de platos' },
    { path: path.join(__dirname, 'admin'), name: 'Admin' }
  ];
  
  dirsToCheck.forEach(dir => {
    const exists = fs.existsSync(dir.path);
    const writable = exists ? (fs.statSync(dir.path).mode & 0o200) !== 0 : false;
    console.log(`📂 ${dir.name}: ${exists ? '✅ Existe' : '❌ No existe'} ${exists ? (writable ? '(Escritura habilitada)' : '(Solo lectura)') : ''}`);
  });
  
  console.log('='.repeat(60));
});

// Manejo de errores del servidor
server.on('error', (error) => {
  console.error('❌ Error del servidor:', error);
  
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof PORT === 'string' ? 'Pipe ' + PORT : 'Port ' + PORT;

  // Mensajes de error amigables
  switch (error.code) {
    case 'EACCES':
      console.error(`❌ ${bind} requiere privilegios elevados`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(`❌ ${bind} ya está en uso`);
      console.log(`💡 Intenta usar un puerto diferente configurando la variable de entorno PORT`);
      process.exit(1);
      break;
    default:
      console.error('❌ Error desconocido:', error);
      throw error;
  }
});

// Manejo de cierre limpio
process.on('SIGTERM', () => {
  console.log('\n🔽 Recibida señal SIGTERM. Cerrando servidor...');
  server.close(() => {
    console.log('👋 Servidor cerrado');
    process.exit(0);
  });
  
  // Forzar cierre después de 5 segundos si es necesario
  setTimeout(() => {
    console.error('⚠️ Forzando cierre del servidor...');
    process.exit(1);
  }, 5000);
});

// Manejo de excepciones no capturadas
process.on('uncaughtException', (error) => {
  console.error('⚠️ Excepción no capturada:', error);
  // No salir del proceso en desarrollo para permitir la depuración
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});

// Manejo de promesas rechazadas no manejadas
process.on('unhandledRejection', (reason, promise) => {
  console.error('⚠️ Promesa rechazada no manejada:', reason);
  // Opcional: registrar el error o cerrar recursos
});
